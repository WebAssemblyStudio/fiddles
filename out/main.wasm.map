{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","rlp.ts","main.ts","~lib/util/string.ts","~lib/util/number.ts","~lib/array.ts","~lib/util/error.ts","~lib/rt.ts","~lib/rt/stub.ts","~lib/memory.ts","~lib/util/memory.ts","~lib/typedarray.ts","~lib/arraybuffer.ts","~lib/dataview.ts","~lib/polyfills.ts","~lib/builtins.ts"],"names":[],"mappings":"6USaM,EAAO,WAIP,AAFS,AAAC,AADJ,EAAS,KACC,WAAsB,GAAW,KAExC,AADK,IACiB,MAG7B,AAAY,EAFE,AAAC,AAAC,EAAS,GAAM,KAAU,KAAa,aAE3B,KACzB,AAAY,IAAe,SAG1B,IAET,AADY,AAAkB,EAAM,KACvB,KACb,EAAe,eCAK,IC8HhB,AD9HM,EAAK,KCqIX,EAAO,KACL,AAAC,EAAM,GAAM,AAAC,EAAO,QAChB,EAAO,KACR,AAAC,KACH,OACQ,SAAiB,SAAjB,EAAQ,AAAS,cAEtB,EAAK,MACC,EAAM,AAAU,QAC3B,EAAQ,KACR,EAAQ,KACR,EAAQ,YAGL,IACK,SAAiB,SAAjB,EAAQ,AAAS,QACzB,YAGA,AAAC,EAAM,GAAM,AAAC,EAAO,QAChB,AAAC,EAAO,GAAK,KACd,AAAC,KACK,EAAO,AAAE,QAAG,AAAS,EAAM,eAEhC,EAAK,MAEC,EAAO,AADlB,EAAK,MACgB,AAAU,EAAM,gBAGlC,IACK,EAAO,AAAE,QAAG,AAAS,EAAM,oBHnJ5B,AAHD,AAAQ,EAAmB,MAGnB,AADP,AAAQ,AADJ,EAAiB,KACD,SAEjC,EAA+C,KAC/C,EAAgD,KACrC,EAA0B,KACjC,IAAkB,EAAQ,EAAM,eG8J9B,ADzLW,KC0LL,EAAM,KACN,EAAO,GAAI,GAAG,KACpB,EAAK,KAEC,EAAO,GAAG,KACV,EAAO,GAAG,KACV,EAAO,KAAI,GAAG,KACd,EAAW,GAAG,KACpB,EAAK,KACC,EAAO,GAAG,KACV,EAAO,GAAI,GAAG,KACpB,EAAK,KAKT,EAAK,AAFU,EAAC,GAAO,QAQZ,AAPX,EAAQ,KAOS,KACN,AAAO,AANlB,EAAK,KAMM,GAAW,GAAG,KACrB,EAAK,KACE,EAAO,GAAG,KACV,EAAO,GAAG,KACV,EAAO,KAAI,GAAI,KACf,EAAW,GAAG,KACrB,EAAK,KACE,EAAO,GAAI,KACX,EAAO,GAAI,KACX,EAAO,GAAI,KACX,EAAO,GAAI,KACX,EAAO,KAAI,GAAI,KACf,EAAW,GAAI,KACf,EAAW,GAAI,KACf,EAAW,GAAI,KAIlB,AADJ,AAAK,AAAC,EAAO,GAAb,KACJ,KACA,EAAK,OAIE,EAAK,KACC,EAAM,KACN,EAAO,GAAG,KACV,EAAO,GAAI,KACX,EAAO,GAAI,KACtB,EAAK,KACL,EAAQ,aLtNN,WAA0E,cAE9E,AGcK,AHfyC,EAAU,EAAc,EENS,MFOzC,KAC1B,KAAoB,AAAO,YOgB4B,AAA5D,AAAkB,EAA0B,WDguCjD,AA5aoC,EA4ajB,OACA,eAiBnB,EAAa,GAAa,OACP,eHtvChB,AGwvC8B,EAAoB,qBAEzD,EAAiB,KACjB,EAAgB,EAA4B,cAxBxC,EAAmB,OACA,iBAGnB,EAAS,KACP,EAAU,KAER,IAAoB,SACD,eAER,MAGM,oBAKK,QACP,eHtvChB,AGwvC8B,EAAoB,qBAEzD,EAAiB,KACjB,EAAgB,YC/vCV,EAAc,SAAyC,cAE/C,AADC,AAAQ,EAAe,MACb,SDkEnB,EAAc,AAAK,QAAsC,eAC7C,KAAiB,WHzF/B,EAAO,AADG,AAAO,AADT,AAAkB,EAAM,aAItB,AADC,AAAQ,EAAM,SACP,EAAK,IACnB,KAEN,EAAe,aH7Bb,EAAU,AADI,OACY,MACxB,EAAU,MAAkB,MAAgC,cAIpD,AADE,AAAU,AAFV,AAAkB,OAEC,AADf,EAAW,SAEP,GAAgB,EAAc,KAChD,EAAY,KACD,EAA0B,KACvC,EAA+C,MAEjD,EAAgD,WA+FnC,OAMF,EAAyB,EAAQ,GAAG,IAcpC,KAAiB,GAAgC,KAZxD,EAAS,KAAQ,EAAe,EAAQ,YHkN/B,AAAiB,SAIhB,EUzTF,AAAL,QV2TP,EAAS,AADL,EAAI,KACM,EAAa,IAAM,KAEjC,EAAS,AADL,EAAI,GACM,EAAa,IAAK,KAJO,kBMvRlC,2GIlCO,AAAL,SDqlCD,AAp9BgC,EAo9BxB,KAAI,AAAI,AAAM,EAAN,cAAkB,aAClC,EAAQ,KAAI,AAAI,AAAM,EAAN,cAAkB,aHpjCnC,AGsjC8B,EAAoB,MAC9C,qBACX,EAAgB,KAAkB,MAClC,EAAiB,AAAC,UAAM,aCtmCV,AADC,AAAiB,EAAqB,MAC5B,SJ6ClB,2CI3CL,EAAiB,KACjB,EAAkB,YCAhB,AAAI,EAAkB,OACtB,AAAI,EAAkB,GAAa,AAAK,QACnB,cLwClB,wCKrCL,EAAiB,AADD,EAA4B,MAE5C,EAAkB,UDFwC,AAA7C,KAAiB,AAAkB,SCqE5C,EAAmB,AAAK,QAAsC,eAClD,WAKd,AACI,EAAiB,QACA,eChGd,AAAI,AAAC,ADiGI,AAAU,UCjGL,GAAK,AAAE,OAAS,STuM5B,EAAyB,AADpB,AADH,OACY,KACsB,IAEhC,KAAiB,AAAC,EAAiB,IAAe,KAIjE,EAAe,WJtDX,AWhIQ,AAAL,QXiIa,eAIhB,AADY,EAAM,MACL,MAGN,AAAY,AAAY,EAAe,EAAG,IAAG,IAAO,EAAe,aACnE,EAAa,MAGX,EAAY,UAEjB,EAAa,MAIN,AAAY,AOhHtB,QPgHqD,IAAO,EAAe,cAGjE,EAAe,EAAG,MAEzB,EAAU,KAAK,EAAK,IAAK,UACT,eAED,AAAY,EAAM,IAAO,EAAe,aACpD,EAAa,MOzHnB,AHEE,MJ4Ie,AO9IjB,AHEE,KJ4I0C,IAAmB,GAAG,AAbrD,EAAY,cAmBtB,AAjBa,EAAU,SAiBT,KACP,OAEP,MAAc,KACP,YAGP,MAAU,KACI,eAId,AWlMI,AAAL,AXiMQ,EAAe,QAAS,YACR,KAEP,eAED,AAAY,EAAM,IAAO,EAAe,AAAS,MAAT,cACpD,EAAa,MAMJ,EAAe,EAAG,AADzB,EAAY,cO1KpB,eIlCO,AAAL,OXiNC,EAAa,AADL,AAAQ,WAEJ,WAEG,AAAY,EAAM,IAAU,EAAe,aAOjD,EAAe,EAAG,AAHjB,EAAY,gBAYtB,AAJc,EAAc,QAKZ,eAMhB,AW3OI,AAAL,AXyOa,EAAe,MAAS,YAGpB,eO1MnB,eIlCO,AAAL,OXsPC,EAAa,AAFL,AAAQ,WAGJ,WAIG,AAAY,EAAM,IAAU,EAAe,EU3HhC,iBChItB,AAAL,AXuHH,AADM,AAAQ,cAEE,eAEb,QI3CC,EAAc,AAAK,QAA8B,eAGrD,EAAc,AAAK,KAAoB,MAAmC,eGhDzE,AHqDU,KAAiB,AAAC,EAAgB,UMyrB7C,EAAc,AAAK,KAAoB,MAAqC,eAC/D,KAAiB,AAAC,EAAgB,UTzjB5C,KGhLK,AAAL,OHkLL,AGlLU,AAAL,KHkLe,KACb,UAEA,AGrLG,AAAL,KHqLsB,KAyBzB,AAJe,AAFJ,AAjBL,EAAU,OAiBM,IAEC,GAIR,mBGpKf,EAAc,AAAK,QAAuD,eAKhB,AAA/C,KAAiB,WOvFpB,AAAL,SVoSK,AAAiB,EAAM,SAIrB,EAAI,KAElB,EAAQ,AADJ,EAAI,KACK,EAAS,IAAM,KAE5B,EAAQ,AADJ,EAAI,GACK,EAAS,IAAK,KAJJ,kBGoFT,AAXE,AG/UX,AH8UyC,AADrC,AAAI,AADgC,MAFhC,iBACL,EAAQ,KAAI,AAAI,EAAQ,cAAa,0BAGS,EAAc,EEnWW,SF+WtD,AAVV,KAAiB,GAUG,eHrH9B,EG/NO,AAAL,QHoOH,EAAK,IAAM,EAAK,OAGhB,mBAxQU,AAAiB,KAIZ,AMuBd,AHEE,AGFF,gBNvBiD,KAGtC,AAAiB,KAShB,AMWZ,cNXmD,MAGvC,AADa,OAGR,AAAgB,MAGjC,EAAc,KAAwB,EAAI,IAMlC,AAAuB,AAFH,EAAsB,QAKnC,AAAgB,AADjB,QAIP,EAAG,EAAgB,IAOb,AAAO,AAFM,EAAoB,QA2BtC,AMzCR,AHEE,KHuCyC,MAIjC,AAAiB,AAFd,AAAgB,MAEa,QAKjC,EG5CF,AAAL,AH4CW,WAMX,EAAc,KAAuB,UU1FhC,AAAL,AV0F0D,KAAuB,UAAkB,IACpG,IAOA,AAAC,EAAS,IAAM,EAAW,UAC1B,AAAC,EAAS,IAAM,EAAW,WAC3B,AAAC,EAAS,IAAM,EAAW,WAC3B,AAAC,EAAS,IAAM,EAAW,QAEhB,eAWd,AANY,AAAY,AADT,AAAO,KAAuB,qBAQ5B,KAAsB,EAAS,QAC3C,EAAO,KAIV,AGhFM,AAAL,AHgFD,QAAgC,KAClB,eAQP,AM/FR,AHEE,AH6FuB,QAA4B,YAMtD,OAMa,KAAsB,MACpB,KAAsB,MAiBnC,AA2HJ,AAlIgC,AADO,SAmI/B,IAAK,KACR,EAAc,KAEd,EAAc,OAjIiC,AAFd,EAAe,QGlH3C,AAAL,QHyHa,eAcd,AGvIM,AHqIyB,EGrIzB,AAAL,aHyIC,AUjLI,AAAL,AViLC,QAA4B,KACd,eAOX,UASH,AADK,AM/JR,AHEE,AH6JuB,QAA0B,iBA7GP","sourceRoot":"assemblyscript:///","sourceContents":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒═══════════════�� Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags;\n  /** Base class id or `0` if none. */\n  base: u32;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `Set`. */\n  SET = 1 << 2,\n  /** Type is a `Map`. */\n  MAP = 1 << 3,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 4,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 5,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 6,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 7,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 8,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 9,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 10,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 11,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 12,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 13,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 14,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 15,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 16,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 17,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 18,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 19,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 20,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 21,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 22\n}\n","// RLP code is taken from https://github.com/nearprotocol/assemblyscript-rlp\n// a couple of bugs in the original code are fixed here.\n\n@external(\"main\", \"sayHello\")\nexport declare function sayHello(a: i32): void;\n\n@external(\"main\", \"debug\")\nexport declare function debug(a: i32): void;\n\n/**\n * class that represents data in rlp format. Due to the lack of support for recursive\n * data types, we have to use a class instead.\n */\nexport class RLPData {\n  // the buffer is actually coming back as an ArrayBuffer\n    buffer: Uint8Array;\n    children: RLPData[];\n\n    constructor(input: Uint8Array, children: RLPData[]) {\n        this.buffer = input;\n        this.children = children;\n    }\n}\n\nconst hexAlphabet = '0123456789abcdef';\n\nexport class Decoded {\n    data: RLPData;\n    remainder: Uint8Array;\n\n    constructor(data: RLPData, remainder: Uint8Array) {\n        this.data = data;\n        this.remainder = remainder;\n    }\n}\n\n/**\n * Parse integers. Check if there is no leading zeros\n * Note that this is NOT safe in assemblyscript due to\n * the lack of error handling.\n * @param v The value to parse\n * @param base The base to parse the integer into\n */\nfunction safeParseInt(v: string, base: u32): u32 {\n    if (v.slice(0, 2) == '00') {\n        throw new Error('invalid RLP: extra zeros');\n    }\n    return parseI32(v, base) as u32;\n}\n\n/** Transform an integer into its hexadecimal value */\nfunction intToHex(integer: u32): string {\n    let res = new Array<string>();\n    do {\n        let t = integer / 16;\n        let r = integer % 16;\n        integer = t;\n        res.push(hexAlphabet[r]);\n    } while (integer);\n    let hex = res.reverse().join('');\n    return hex.length % 2 ? \"0\" + hex : hex;\n}\n\nfunction bytesToHex(bytes: Uint8Array): string {\n    let res = new Uint8Array(bytes.length * 2);\n    for (let i = 0; i < bytes.length; i++) {\n        let hex = intToHex(bytes[i]);\n        res[i*2] = hex.charCodeAt(0);\n        res[i*2+1] = hex.charCodeAt(1);\n    }\n    return String.fromUTF8(res.buffer.data, res.byteLength);\n}\n\nfunction hexToBytes(hex: string): Uint8Array {\n    if (!hex.length) {\n        return null;\n    }\n    assert(hex.length % 2 == 0);\n    let byteLength = hex.length / 2;\n    let res = new Uint8Array(byteLength);\n    for (let i = 0; i < byteLength; i++) {\n        res[i] = parseI32(hex.substr(i*2, 2), 16) as u8;\n    }\n    return res;\n}\n\nfunction concatUint8Array(arr1: Uint8Array, arr2: Uint8Array): Uint8Array {\n    let len = arr1.byteLength + arr2.byteLength;\n    let res = new Uint8Array(len);\n    memory.copy(res.buffer.data, arr1.buffer.data + arr1.byteOffset, arr1.byteLength);\n    memory.copy(res.buffer.data + arr1.length, arr2.buffer.data + arr2.byteOffset, arr2.byteLength);\n    return res;\n}\n\nfunction concatUint8Arrays(arrays: Array<Uint8Array>): Uint8Array {\n    let len = arrays.reduce<u32>(((acc, x) => acc + x.byteLength), 0);\n    let res = new Uint8Array(len);\n    let counter = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        memory.copy(res.buffer.data + counter, arrays[i].buffer.data + arrays[1].byteOffset, arrays[i].byteLength);\n        counter += arrays[i].byteLength;\n    }\n    return res;\n}\n\n/**\n * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP\n * This function takes in an argument of type Input and returns the rlp encoding of it.\n * @param input: a Uint8Array or an array of inputs.\n * @returns returns rlp encoded byte array.\n **/\nexport function encode(input: RLPData): Uint8Array {\n    if (input.children) {\n        let output = new Array<Uint8Array>();\n        for (let i = 0; i < input.children.length; i++) {\n            output.push(encode(input.children[i]));\n        }\n        let buf = concatUint8Arrays(output);\n        return concatUint8Array(encodeLength(buf.length, 192), buf);\n    } else {\n        if (input.buffer.length == 1 && input.buffer[0] < 128) {\n            return input.buffer;\n        }\n        return concatUint8Array(encodeLength(input.buffer.length, 128), input.buffer);\n    }\n}\n\nfunction encodeLength(len: u32, offset: u32): Uint8Array {\n    if (len < 56) {\n        return hexToBytes(intToHex(len + offset));\n    } else {\n        let hexLength = intToHex(len);\n        let lLength = hexLength.length / 2;\n        let firstByte = intToHex(offset + 55 + lLength);\n        return concatUint8Array(hexToBytes(firstByte), hexToBytes(hexLength));\n    }\n}\n\n/**\n * RLP Decoding based on: {@link https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP|RLP}\n * @param input - Uint8Array\n * @returns - returns RLPData containing the original message\n **/\nexport function decode(input: Uint8Array): RLPData {\n    let res = _decode(input);\n    if (res.remainder.length != 0) {\n        throw new Error('invalid remainder');\n    }\n    return res.data;\n}\n\nexport function _decode(input: Uint8Array): Decoded {\n    //sayHello(100);\n    let length: u32;\n    if (!input.length) {\n        throw new Error('invalid input: cannot be empty');\n    }\n    //sayHello(99);\n    let firstByte = input[0];\n    if (firstByte <= 0x7f) {\n        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\n        //sayHello(98);\n        return new Decoded(new RLPData(input.subarray(0, 1),null), input.subarray(1));\n    } else if (firstByte <= 0xb7) {\n        // a string 0-55 bytes long\n        //sayHello(97);\n        length = firstByte - 0x7f;\n        //sayHello(length);\n        if (firstByte == 0x80) {\n            // if firstByte is 0x80 then the string is one byte long (0x80 - 0x7f)\n            // 0x80 is the null byte (iirc)\n            //sayHello(97978080);\n            return new Decoded(new RLPData(new Uint8Array(0), null), input.subarray(length));\n        }\n\n        let data = input.subarray(1, length);\n        //sayHello(97978181);\n        if (length == 2 && data[0] < 0x80) {\n            throw new Error('invalid rlp encoding: byte must be less 0x80');\n        }\n        return new Decoded(new RLPData(data, null), input.subarray(length));\n    } else if (firstByte <= 0xbf) {\n        // a string longer than 55 bytes\n        // firstByte is between 0xb7 and 0xbf\n\n        //sayHello(96);\n        //sayHello(input.length);\n        let input_ptr = changetype<usize>(input.buffer);\n        //debug(input_ptr + input.byteOffset);\n        let llength = firstByte - 0xb6;\n        // 0xb6 is used because the slice/subarray operator  exclusive and wants length + 1;\n        let len_length = llength - 1;\n        // if the string is longer than 256 bytes, then the length needs to be read from two bytes\n        // if its longer than 65536 then it needs three bytes\n        // llength is the \"length of the length\"\n\n        //sayHello(33);\n        //sayHello(llength); \n\n        //length = safeParseInt(bytesToHex(input.subarray(1, llength)), 16);\n        //length = i32(input.subarray(1, llength));\n\n        var length_view = new DataView(input.buffer, input.byteOffset + 1, llength);\n\n        //sayHello(77);\n        //sayHello(length_view.byteLength);\n        //debug(length_view.dataStart);\n\n        if (len_length == 1) { // read length from one byte\n          length = length_view.getUint8(0);\n        }\n        if (len_length == 2) { // read length from two bytes\n          length = length_view.getUint16(0);\n        }\n        //sayHello(length);\n        if (llength > 3) {\n          throw new Error('TODO');\n        }\n\n        let data = input.subarray(llength, length + llength);\n        if ((data.length as u32) < length) {\n            //sayHello(666);\n            throw new Error('invalid RLP');\n        }\n        return new Decoded(new RLPData(data, null), input.subarray(length + llength));\n    } else if (firstByte <= 0xf7) {\n        // short list 0-55 bytes\n        // firstByte is between 0xbf and 0xf7\n\n        //sayHello(95);\n        length = firstByte - 0xbf;\n        let remainder = input.subarray(1, length);\n        let decoded: RLPData[] = [];\n        while (remainder.length) {\n            let d = _decode(remainder);\n            decoded.push(d.data);\n            remainder = d.remainder;\n        }\n        return new Decoded(new RLPData(null, decoded), input.subarray(length));\n    } else {\n        //sayHello(94);\n        // a list over 55 bytes long\n        let llength = firstByte - 0xf6;\n\n        // TODO: use a DataView here to read the length, for better clarity\n        length = i32(input.subarray(1, llength));\n\n        // old code, not sure if safeParseInt is actually necessary\n        //length = safeParseInt(bytesToHex(input.subarray(1, llength)), 16);\n\n        let totalLength = i32(llength + length);\n\n        //sayHello(1);\n        //if (totalLength > i32(input.length)) {\n        if (totalLength == 0) { // TODO: check this\n            throw new Error('invalid rlp: total length is larger than the data');\n        }\n\n        //sayHello(2);\n        let remainder = input.subarray(llength, totalLength);\n\n        if (remainder.length == 0) {\n            throw new Error('invalid rlp, List has a invalid length');\n        }\n\n        //sayHello(3);\n        let decoded: RLPData[] = [];\n        while (remainder.length) {\n            //sayHello(remainder.length)\n            //sayHello(4);\n            let d = _decode(remainder);\n            //sayHello(6);\n            decoded.push(d.data);\n            remainder = d.remainder;\n            //sayHello(7);\n        }\n        //sayHello(5);\n        return new Decoded(new RLPData(null, decoded), input.subarray(totalLength));\n    }\n}\n","\nimport { keccak } from \"./keccak\";\nimport { RLPData, decode } from \"./rlp\";\n\nexport declare function sayHello(a: i32): void;\n\n@external(\"main\", \"debug\")\nexport declare function debug(a: i32): void;\n\n@external(\"env\", \"eth2_blockDataSize\")\nexport declare function getBlockDataSize(): i32;\n\n@external(\"env\", \"eth2_blockDataCopy\")\nexport declare function copyBlockData(srcOffset: i32, length: i32, outputOffset: i32): void;\n\n\n/**\n * Verify a proof for the Ethereum Merkle-Patricia-Trie.\n * \n * Verification logic was ported from https://github.com/ethereumjs/merkle-patricia-tree/blob/v3.0.0/src/proof.js#L31-L39.\n * \n * \n * Input:\n *   * `proof_nodes[]`: a merkle proof, which is an array of nodes (from the root node to the account leaf)\n *   * pre-state root. should match `keccak(proof_nodes[0])`\n *   * account address\n *     * keccak(address) is in the leaf node, but the address itelf is the hash preimage and thus unknown unless included in the input\n *     * technically, only the latter part of keccak(address) is in the leaf node (some initial portion is the \"key\" or \"path\" from the root to the leaf)\n * \n */\n\nexport function mpt_verify(): i32 {\n\n  var root_hash = Array.create<u8>(32);\n  // 0x65b7b9ccb7a4d828986e488e081bc11bfa5ef6141fb06b0af2e9a0bda273a753\n  root_hash = [101, 183, 185, 204, 183, 164, 216, 40, 152, 110, 72, 142, 8, 27, 193, 27, 250, 94, 246, 20, 31, 176, 107, 10, 242, 233, 160, 189, 162, 115, 167, 83];\n  // Uint64Array is more efficient than Uint8Array, because we can test equivalence by checking 4 elements\n  var root_hash_data = Uint64Array.wrap(root_hash.buffer, 0, 4);\n  //var root_hash_data = Uint8Array.wrap(root_hash.buffer, 0, 32);\n\n  var address_raw = Array.create<u8>(20);\n  /**\n   * keccak(address) is the key for the leaf node\n   * the key is used when verifying the proof\n   * hex chars in the key give the path down from the root node, through the branch nodes, and to the leaf\n   */\n\n  // keccak(\"6cdf39d8d75538a0cad721f24276ec48562e5c90\")\n  address_raw = [108, 223, 57, 216, 215, 85, 56, 160, 202, 215, 33, 242, 66, 118, 236, 72, 86, 46, 92, 144];\n  var address_data = Uint8Array.wrap(address_raw.buffer, 0, 20);\n\n  var keccakCtx = new ArrayBuffer(650); // more than 616 (see the docs in keccak.tx)\n  var keccakCtxBuf = changetype<usize>(keccakCtx);\n\n  var addressHashOutput = new ArrayBuffer(32);\n  var addressHashOutputPtr = changetype<usize>(addressHashOutput);\n\n  keccak(keccakCtxBuf, address_data.dataStart, 20, addressHashOutputPtr);\n  //debug(addressHashOutputPtr);\n\n  // use Uint8 for address_hash because it'll be converted into nibbles\n  var address_hash = Uint8Array.wrap(addressHashOutput, 0, 32);\n\n  let key_path = getPathFromAddressHash(address_hash);\n  \n  var input_data_len = getBlockDataSize();\n  var input_data_buff = new ArrayBuffer(input_data_len);\n  var input_data_buff_ptr = changetype<usize>(input_data_buff);\n\n  copyBlockData(0, input_data_len, input_data_buff_ptr);\n\n  //sayHello(888);\n  //sayHello(input_data_len);\n\n  var input_data = Uint8Array.wrap(input_data_buff, 0, input_data_len);\n\n  var proof_decoded = decode(input_data);\n  // decoded result: { data: RLPData[], remainder: Uint8Array }\n  // decode() returns result.data\n  // RLPData: { buffer: Uint8Array, children: RLPData[] }\n\n  //sayHello(999);\n  //sayHello(proof_decoded.children.length);\n\n  /***\n  *   to verify the proof (proves that a leaf is in the trie), we also need the key for the leaf.\n  *  the key is the hash of the address.\n  *   keccak(\"6cdf39d8d75538a0cad721f24276ec48562e5c90\")\n  * \n  *  the key tells us what path to follow in order to verify the proof\n  *  the root node is always branch node (iirc).\n  *  the first byte of the key tells us which branch index to follow from the root node\n  *  get the hash at that branch index.\n  *  then go to the next node in the proof and hash it, and check that the hashes match\n  *\n  **/\n\n  // key_path_i counter tracks how many nibbles in the key_path have been traversed (starting from the root node)\n  let kp_i = 0; \n\n  // wantHash is initially set to the root hash, because the root node is first one processed in the main loop\n  var wantHash = Uint64Array.wrap(root_hash.buffer, 0, 4);\n\n  var hashOutputBuf = new ArrayBuffer(32);\n  //var hashOutput = Uint8Array.wrap(hashOutputBuf, 0, 32);\n  var hashOutput = Uint64Array.wrap(hashOutputBuf, 0, 4);\n  var hashOutputPtr = changetype<usize>(hashOutputBuf);\n\n\n  // Main Loop. process each node in the proof starting from the root node, down to the leaf\n  for (let i = 0; i < proof_decoded.children.length; i++) {\n    //sayHello(55555);\n    //sayHello(i);\n\n    // hash the node and check it against wantHash\n    // reuse the same context, and same output\n    keccak(keccakCtxBuf, proof_decoded.children[i].buffer.dataStart, proof_decoded.children[i].buffer.length, hashOutputPtr);\n    debug(hashOutputPtr);\n\n    //debug(wantHash.dataStart);\n    //debug(wantHash.length);\n    //debug(changetype<usize>(root_hash));\n    //debug(changetype<usize>(root_hash_data.buffer));\n\n    if (  (wantHash[0] != hashOutput[0])\n        || (wantHash[1] != hashOutput[1])\n        || (wantHash[2] != hashOutput[2])\n        || (wantHash[3] != hashOutput[3]) ) {\n      //sayHello(696969);\n      throw new Error('hashes dont match!');\n    }\n\n    // RLP decode the trie node\n    let node_decoded = decode(proof_decoded.children[i].buffer);\n    let node_type = getNodeType(node_decoded.children);\n\n    //sayHello(node_decoded.children.length);\n    //sayHello(54321);\n\n    // NEXT STEP. use key_path[kp_i] to get the next wantHash\n    if (node_type == NodeType.Branch) {\n      var next_in_path = node_decoded.children[key_path[kp_i]];\n      kp_i = kp_i + 1;\n\n      // TODO: if key.length === 0 throw\n\n      if (next_in_path.children.length == 2) {\n        throw new Error('TODO: handle embedded node');\n      }\n\n      //sayHello(121212);\n      //debug(next_in_path.buffer.dataStart);\n\n      //wantHash = next_in_path.buffer;\n      //next_in_path.buffer.byteOffset\n      wantHash = Uint64Array.wrap(next_in_path.buffer.buffer, next_in_path.buffer.byteOffset, 4);\n      //debug(wantHash.dataStart);\n\n    } // end branch case\n\n\n    if (node_type == NodeType.Leaf) {\n      //sayHello(131313);\n      // TODO: extension node handled here too\n\n      // step 1. check that the node's key matches the path key\n\n      let node_key = node_decoded.children[0];\n      let node_value = node_decoded.children[1];\n\n      //debug(1311);\n      //debug(node_key.buffer.dataStart);\n      /// node_key.buffer 200cd89ae762119fed6ecd8dc969077bb2d6a3471c639a10e710a9374a121db8\n\n      // key: 2         25b40cd89ae762119fed6ecd8dc969077bb2d6a3471c639a10e710a9374a121d\n\n      // node_key needs to become an array of nibbles\n      let node_key_nibs = uintArrToNibbleArr(node_key.buffer);\n      node_key_nibs = removeHexPrefix(node_key_nibs);\n\n      let sliced_path_for_nibble_matching = key_path.slice(kp_i);\n      //debug(1212);\n      let match_len = matchingNibbleLength(node_key_nibs, sliced_path_for_nibble_matching);\n      //debug(match_len);\n\n      if (match_len !== node_key_nibs.length) {\n        //sayHello(1393939);\n        throw new Error('Key does not match with the proof one (extention|leaf)');\n      }\n\n      // TODO: should increment kp_i here?\n      // in the current test vector, the leaf case is terminal so it doesn't matter\n      // kp_i = kp_i + node_key_nibs.length;\n\n      //debug(kp_i);\n      //debug(key_path.length);\n      //debug(sliced_path.length);\n\n      // TODO: we need another slice of the key_path\n      let sliced_path_for_length_check = sliced_path_for_nibble_matching.slice(node_key_nibs.length);\n\n      if (sliced_path_for_length_check.length == 0) { // TODO: check this == 0\n        //sayHello(141414);\n        if (node_value.buffer.length == 17) {\n          throw new Error('TODO: handle embedded branch');\n        }\n        // TODO check that this is the last node in the proof\n        // i !== proof.length - 1\n\n        //sayHello(6969696);\n        //debug(node_value.buffer.dataStart);\n        return node_value.buffer.dataStart;\n\n      }\n\n      //sayHello(151515);\n      //debug(node_value.buffer.dataStart);\n\n      //next_in_path.buffer.byteOffset\n      wantHash = Uint64Array.wrap(node_value.buffer.buffer, node_value.buffer.byteOffset, 4);\n      debug(wantHash.dataStart);\n    } // end leaf case\n\n\n  } // close for loop\n\n\n  return 123;\n\n}\n\n\n\nenum NodeType {\n  Branch,\n  Leaf,\n  Extension,\n  Err\n}\n\n\nfunction getNodeType(node_data: RLPData[]): NodeType {\n  sayHello(789);\n  sayHello(node_data.length);\n  if (node_data.length == 17) {\n    sayHello(171717);\n    return NodeType.Branch;\n  } else if (node_data.length == 2) {\n    // first nibble of the key is a node type indicator\n    let key = node_data[0];\n\n    /**\n     * three main AS types for dealing with data:\n     * (1) ArrayBuffer  (2) UintXArray (aka TypedArray) (3) DataView\n     * ArrayBuffer is the \"backing buffer\" for both TypedArray and DataViews (access with uint_arr.buffer and data_view.buffer)\n     * \n     * Note that you cannot read directly from an ArrayBuffer, you need to wrap it in a TypedArray or a DataView\n     * \n     * To read from a DataView, you use `data_view.getUint8(0)` or `getUint64(19)`\n     * To read from a TypedArray, you use `uint_arr[0]` or `uint_arr[19]`.\n     * So the difference is a DataView lets you read any width uints, but a UintXArray you can only read width X.\n     * \n     * The RLPData class uses Uint8Arrays, but is confusingly named `rlp_node.buffer` (the backing buffer is at `rlp_node.buffer.buffer`)\n     * TODO: rename it to rlp_node.data (or something)\n     */\n\n    let bkey = i32(key.buffer[0]);\n    // we only need to check the first nibble here\n    let first_nibble = bkey >> 4;\n    // second nibble = bkey % 16;\n\n    // if isTerminator(key)\n    if (first_nibble > 1) {\n      //sayHello(3333);\n      return NodeType.Leaf;\n    }\n\n    return NodeType.Extension;\n  }\n\n  //sayHello(66666);\n  return NodeType.Err;\n}\n\n\nfunction matchingNibbleLength(nib1: Array<u8>, nib2: Array<u8>): i32 {\n  //debug(1231);\n\n  var i = 0;\n  for (; i < nib1.length; i++) {\n    //debug(i);\n    //debug(nib1[i]);\n    //debug(nib2[i]);\n\n    if (nib1[i] != nib2[i]) {\n      break;\n    }\n    i = i + 1;\n  }\n  \n  //debug(i);\n  //debug(1241);\n  return i;\n}\n\n\nfunction removeHexPrefix(nib_arr: Array<u8>): Array<u8> {\n  // the hex prefix is merkle-patricia-trie encoding, not RLP\n  if (nib_arr[0] % 2) {\n    return nib_arr.slice(1);\n  } else {\n    return nib_arr.slice(2);\n  }\n}\n\nfunction uintArrToNibbleArr(uint_arr: Uint8Array): Array<u8> {\n  var len = uint_arr.length;\n\n  var nib_arr = Array.create<u8>(len * 2); // length is num of hex chars for address_hash\n  // TODO: we might not need to convert the whole thing to nibbles, just enough chars to follow the path to the proof\n\n  let q = 0;\n  for (let i = 0; i < len; i++) {\n    q = i * 2;\n    nib_arr[q] = uint_arr[i] >> 4;\n    q = q + 1;\n    nib_arr[q] = uint_arr[i] % 16;\n  }\n\n  return nib_arr;\n}\n\n\nfunction getPathFromAddressHash(address_hash: Uint8Array): Array<u8> {\n\n  var key_path = Array.create<u8>(64); // length is num of hex chars for address_hash\n  // TODO: we probably don't need to convert the whole thing to nibbles, just enough chars to follow the path to the proof\n\n  let q = 0;\n  for (let i = 0; i < address_hash.length; i++) {\n    q = i * 2;\n    key_path[q] = address_hash[i] >> 4;\n    q = q + 1;\n    key_path[q] = address_hash[i] % 16;\n  }\n\n  // Note: getting a pointer using changetype on key_path, a regular Array, is not working\n  // debug(changetype<usize>(key_path));\n\n  return key_path;\n}\n\n\n\n\n\n\n\n  /** \n  * input rlp: f86b9f200cd89ae762119fed6ecd8dc969077bb2d6a3471c639a10e710a9374a121db849f8478083ffffffa056e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421a0c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n  * output: got decoded rlp: [ <Buffer 20 0c d8 9a e7 62 11 9f ed 6e cd 8d c9 69 07 7b b2 d6 a3 47 1c 63 9a 10 e7 10 a9 37 4a 12 1d>,\n  *<Buffer f8 47 80 83 ff ff ff a0 56 e8 1f 17 1b cc 55 a6 ff 83 45 e6 92 c0 f8 6e 5b 48 e0 1b 99 6c ad c0 01 62 2f b5 e3 63 b4 21 a0 c5 d2 46 01 86 f7 23 3c 92 ... 23 more bytes> ]\n  */\n\n\n  /* ** this is what I started before deciding to first ask if anyone has already implemented RLP in AS.\n\n  var buff = new ArrayBuffer(10);\n  var view1 = new DataView(buff);\n  view1.setUint8(0, 254);\n  view1.setUint8(1, 254);\n  var num = view1.getUint32(0);\n\n  var rlpExample = Array.create<ArrayBuffer>(2);\n  rlpExample[0] = new ArrayBuffer(5);\n  var viewEl1 = new DataView(rlpExample[0]);\n  viewEl1.setUint8(0, 127);\n  viewEl1.setUint8(1, 127);\n  var rlpnum = viewEl1.getUint32(0);\n  return rlpnum;\n\n  // if input_data[0] <= 0x7f\n  // return one byte\n\n  // else if input[0] <= 0xb7\n  // a string 0-55 bytes long\n\n  // else if input[0] <= 0xbf\n  // a strong longer than 55 bytes\n\n  // else if input[0] <= 0xf7\n  // a list 0-55 bytes long\n\n  // else\n  // a list over 55 bytes long\n  //var list_len = input_data[0] - 0xf6;\n  // totalLength = list_length + input_length;\n  // TODO: check that totalLength <= input_length\n  // TODO: check that list_len == input_length\n  //var decoded_input = Array.create<DataView>(list_len);\n\n  */\n\n\n","export function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  var result = 0;\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\n  while (len && !(result = <i32>load<u16>(ptr1) - <i32>load<u16>(ptr2))) {\n    --len, ptr1 += 2, ptr2 += 2;\n  }\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function isSpace(c: i32): bool {\n  if (c <= 0xFF) {\n    switch (c) {\n      case 0x09: // <TAB>\n      case 0x0A: // <LF>\n      case 0x0B: // <VT>\n      case 0x0C: // <FF>\n      case 0x0D: // <CR>\n      case 0x20: // <SP>\n      case 0xA0: return true; // <NBSP>\n    }\n    return false;\n  }\n  if (c >= 0x2000 && c <= 0x200A) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  // @ts-ignore: cast\n  if (!len) return <T>NaN;\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr);\n\n  // determine sign\n  // @ts-ignore: cast\n  var sign: T = 1;\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <i32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (code == CharCode.MINUS) {\n    // @ts-ignore: cast\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2);\n    // @ts-ignore: type\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    // @ts-ignore: cast\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2);\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2)) {\n        case CharCode.B:\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.O:\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.X:\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    // @ts-ignore: cast\n    return <T>NaN;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr);\n    if (code >= CharCode._0 && code <= CharCode._9) {\n      code -= CharCode._0;\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\n      code -= CharCode.A - 10;\n    } else if (code >= CharCode.a && code <= CharCode.z) {\n      code -= CharCode.a - 10;\n    } else break;\n    if (code >= radix) break;\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\n// FIXME: naive implementation\nexport function strtod(str: string): f64 {\n  var len: i32 = str.length;\n  if (!len) return NaN;\n\n  var ptr = changetype<usize>(str);\n  var code = <i32>load<u16>(ptr);\n\n  // determine sign\n  var sign = 1.0;\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <i32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <i32>load<u16>(ptr += 2);\n    sign = -1.0;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <i32>load<u16>(ptr += 2);\n  }\n\n  // calculate value\n  var num = 0.0;\n  while (len--) {\n    code = <i32>load<u16>(ptr);\n    if (code == CharCode.DOT) {\n      ptr += 2;\n      let fac = 0.1; // precision :(\n      while (len--) {\n        code = <i32>load<u16>(ptr);\n        if (code == CharCode.E || code == CharCode.e) {\n          assert(false); // TODO\n        }\n        code -= CharCode._0;\n        if (<u32>code > 9) break;\n        num += <f64>code * fac;\n        fac *= 0.1;\n        ptr += 2;\n      }\n      break;\n    }\n    code -= CharCode._0;\n    if (<u32>code >= 10) break;\n    num = num * 10 + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\nimport { ArrayBufferView } from \"../arraybuffer\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline\nconst POWERS10: u32[] = [\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n];\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline\nconst DIGITS: u32[] = [\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n];\n\n// @ts-ignore: decorator\n@lazy @inline\nconst EXP_POWERS: i16[] = [\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n];\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline\nconst FRC_POWERS: u64[] = [\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n];\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return select<u32>(1, 2, value < 10);\n    } else {\n      let m = select<u32>(4, 5, value < 10000);\n      return select<u32>(3, m, value < 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return select<u32>(6, 7, value < 1000000);\n    } else {\n      let m = select<u32>(9, 10, value < 1000000000);\n      return select<u32>(8, m, value < 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return select<u32>(11, 12, value < 100000000000);\n    } else {\n      let m = select<u32>(14, 15, value < 100000000000000);\n      return select<u32>(13, m, value < 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return select<u32>(16, 17, value < 10000000000000000);\n    } else {\n      let m = select<u32>(19, 20, value < 10000000000000000000);\n      return select<u32>(18, m, value < 1000000000000000000);\n    }\n  }\n}\n\nfunction utoa32_lut(buffer: usize, num: u32, offset: usize): void {\n  var lut = changetype<ArrayBufferView>(DIGITS).dataStart;\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(lut + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(lut + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(lut + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(lut + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_lut(buffer: usize, num: u64, offset: usize): void {\n  var lut = changetype<ArrayBufferView>(DIGITS).dataStart;\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(lut + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(lut + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(lut + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(lut + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset -= 1;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_core(buffer: usize, num: u32, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa32_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa64_core(buffer: usize, num: u64, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa64_lut(buffer, num, offset);\n  }\n}\n\nexport function utoa32(value: u32): String {\n  if (!value) return \"0\";\n\n  var decimals = decimalCount32(value);\n  var out = __alloc(decimals << 1, idof<String>());\n\n  utoa32_core(out, value, decimals);\n  return changetype<String>(out); // retains\n}\n\nexport function itoa32(value: i32): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var decimals = decimalCount32(value) + u32(sign);\n  var out = __alloc(decimals << 1, idof<String>());\n\n  utoa32_core(out, value, decimals);\n  if (sign) store<u16>(out, CharCode.MINUS);\n  return changetype<String>(out); // retains\n}\n\nexport function utoa64(value: u64): String {\n  if (!value) return \"0\";\n\n  var out: usize;\n  if (value <= u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_core(out, val32, decimals);\n  } else {\n    let decimals = decimalCount64(value);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_core(out, value, decimals);\n  }\n  return changetype<String>(out); // retains\n}\n\nexport function itoa64(value: i64): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var out: usize;\n  if (<u64>value <= <u64>u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32) + u32(sign);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_core(out, val32, decimals);\n  } else {\n    let decimals = decimalCount64(value) + u32(sign);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_core(out, value, decimals);\n  }\n  if (sign) store<u16>(out, CharCode.MINUS);\n\n  return changetype<String>(out); // retains\n}\n\nexport function itoa<T extends number>(value: T): String {\n  if (!isInteger<T>()) ERROR(\"integer type expected\");\n  if (isSigned<T>()) {\n    if (sizeof<T>() <= 4) {\n      return itoa32(<i32>value);\n    } else {\n      return itoa64(<i64>value);\n    }\n  } else {\n    if (sizeof<T>() <= 4) {\n      return utoa32(<u32>value);\n    } else {\n      return utoa64(<u64>value);\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy\nvar _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// var _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n      k += i32(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = unchecked(FRC_POWERS[index]);\n  _exp_pow = unchecked(<i32>EXP_POWERS[index]);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = <i32>((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (u64(exp != 0) << 52) + sid;\n      exp = select<i32>(exp, 1, exp != 0) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp,      exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n  var wp_w_exp = mp_exp;\n\n  var p1 = <u32>(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  var lut = changetype<ArrayBufferView>(POWERS10).dataStart;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(lut + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (1) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(lut + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n\n  return len;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nexport function dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n      len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite<f64>(value)) {\n    if (isNaN<f64>(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var buffer = __alloc(MAX_DOUBLE_LENGTH << 1, idof<String>());\n  var length = dtoa_core(buffer, value);\n  if (length == MAX_DOUBLE_LENGTH) return changetype<String>(buffer);\n  var result = changetype<String>(buffer).substring(0, length);\n  __free(buffer);\n  return result;\n}\n\nexport function itoa_stream<T extends number>(buffer: usize, offset: usize, value: T): u32 {\n  buffer += (offset << 1);\n  if (!value) {\n    store<u16>(buffer, CharCode._0);\n    return 1;\n  }\n  var decimals: u32 = 0;\n  if (isSigned<T>()) {\n    let sign = i32(value < 0);\n    if (sign) value = changetype<T>(-value);\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value) + <u32>sign;\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32) + <u32>sign;\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value) + <u32>sign;\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n    if (sign) store<u16>(buffer, CharCode.MINUS);\n  } else {\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value);\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32);\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value);\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_stream(buffer: usize, offset: usize, value: f64): u32 {\n  buffer += (offset << 1);\n  if (value == 0.0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite<f64>(value)) {\n    if (isNaN<f64>(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = i32(value < 0);\n      let len  = 8 + sign;\n      memory.copy(buffer, changetype<usize>(select<String>(\"-Infinity\", \"Infinity\", sign)), len << 1);\n      return len;\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { ArrayBuffer, ArrayBufferView } from \"./arraybuffer\";\nimport { itoa, dtoa, itoa_stream, dtoa_stream, MAX_DOUBLE_LENGTH } from \"./util/number\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureSize(array: usize, minSize: usize, alignLog2: u32): void {\n  var oldCapacity = changetype<ArrayBufferView>(array).dataLength;\n  if (minSize > oldCapacity >>> alignLog2) {\n    if (minSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).data);\n    let newCapacity = minSize << alignLog2;\n    let newData = __realloc(oldData, newCapacity);\n    memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    if (newData !== oldData) { // oldData has been free'd\n      store<usize>(changetype<usize>(array), __retain(newData), offsetof<ArrayBufferView>(\"data\"));\n      changetype<ArrayBufferView>(array).dataStart = newData;\n    }\n    changetype<ArrayBufferView>(array).dataLength = <u32>newCapacity;\n  }\n}\n\nexport class Array<T> extends ArrayBufferView {\n  [key: number]: T;\n\n  // Implementing ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `data`) and `dataLength` (equals computed `data.byteLength`).\n\n  // Also note that Array<T> with non-nullable T must guard against implicit null values whenever\n  // length is modified in a way that a null value would exist. Otherwise, the compiler wouldn't be\n  // able to guarantee type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return builtin_isArray(value) && value !== null;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    if (<u32>capacity > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    var array = changetype<Array<T>>(__allocArray(capacity, alignof<T>(), idof<T[]>())); // retains\n    changetype<Array<T>>(array).length_ = 0; // safe even if T is a non-nullable reference\n    memory.fill(array.dataStart, 0, <usize>array.dataLength);\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    super(length, alignof<T>());\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (length) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    this.length_ = length;\n  }\n\n  @unsafe get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    var oldLength = this.length_;\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (<u32>newLength > <u32>oldLength) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    if (isManaged<T>()) { // release no longer used refs\n      if (oldLength > newLength) {\n        let dataStart = this.dataStart;\n        do __release(load<usize>(dataStart + (<usize>--oldLength << alignof<T>())));\n        while (oldLength > newLength);\n        // no need to zero memory on shrink -> is zeroed on grow\n      }\n    }\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (!fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (predicate(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (<u32>index >= <u32>this.length_) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    if (<u32>index >= <u32>this.dataLength >>> alignof<T>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return this.__unchecked_get(index);\n  }\n\n  @operator(\"{}\") private __unchecked_get(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    var length = this.length_;\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (<u32>index > <u32>length) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    ensureSize(changetype<usize>(this), index + 1, alignof<T>());\n    this.__unchecked_set(index, value);\n    if (index >= length) this.length_ = index + 1;\n  }\n\n  @operator(\"{}=\") private __unchecked_set(index: i32, value: T): void {\n    if (isManaged<T>()) {\n      let offset = this.dataStart + (<usize>index << alignof<T>());\n      let oldRef: usize = load<usize>(offset);\n      if (changetype<usize>(value) != oldRef) {\n        store<usize>(offset, __retain(changetype<usize>(value)));\n        __release(oldRef);\n      }\n    } else {\n      store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var dataStart = this.dataStart;\n    var length = this.length_;\n    start = start < 0 ? max(length + start, 0) : min(start, length);\n    end   = end   < 0 ? max(length + end,   0) : min(end,   length);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        let oldRef: usize = load<usize>(dataStart + (<usize>start << alignof<T>()));\n        if (changetype<usize>(value) != oldRef) {\n          store<usize>(dataStart + (<usize>start << alignof<T>()), __retain(changetype<usize>(value)));\n          __release(oldRef);\n        }\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          dataStart + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(dataStart + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    return this.indexOf(value, fromIndex) >= 0;\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var dataStart = this.dataStart;\n    while (fromIndex < length) {\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var dataStart = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    var length = this.length_;\n    var newLength = length + 1;\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>length << alignof<T>()), __retain(changetype<usize>(value)));\n    } else {\n      store<T>(this.dataStart + (<usize>length << alignof<T>()), value);\n    }\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = select(0, other.length_, other === null);\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__allocArray(outLen, alignof<T>(), idof<Array<T>>())); // retains\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, __retain(ref));\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, __retain(ref));\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var dataStart = this.dataStart;\n    var len = this.length_;\n\n        end   = min<i32>(end, len);\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    if (isManaged<T>()) {\n      if (from < to && to < (from + count)) { // right to left\n        from += count - 1;\n        to   += count - 1;\n        while (count) {\n          let oldRef: usize = load<usize>(dataStart + (<usize>to << alignof<T>()));\n          let newRef: usize = load<usize>(dataStart + (<usize>from << alignof<T>()));\n          if (newRef != oldRef) {\n            store<usize>(dataStart + (<usize>to << alignof<T>()), __retain(newRef));\n            __release(oldRef);\n          }\n          --from, --to, --count;\n        }\n      } else { // left to right\n        while (count) {\n          let oldRef: usize = load<usize>(dataStart + (<usize>to << alignof<T>()));\n          let newRef: usize = load<usize>(dataStart + (<usize>from << alignof<T>()));\n          if (newRef != oldRef) {\n            store<usize>(dataStart + (<usize>to << alignof<T>()), __retain(newRef));\n            __release(oldRef);\n          }\n          ++from, ++to, --count;\n        }\n      }\n    } else {\n      memory.copy( // is memmove\n        dataStart + (<usize>to << alignof<T>()),\n        dataStart + (<usize>from << alignof<T>()),\n        <usize>count << alignof<T>()\n      );\n    }\n    return this;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\n    var element = load<T>(this.dataStart + (<usize>(--length) << alignof<T>()));\n    this.length_ = length;\n    return element; // no need to retain -> is moved\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var length = this.length_;\n    var out = changetype<Array<U>>(__allocArray(length, alignof<U>(), idof<Array<U>>())); // retains\n    var outStart = out.dataStart;\n    for (let index = 0; index < min(length, this.length_); ++index) {\n      let result = fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this); // retains\n      if (isManaged<U>()) {\n        store<usize>(outStart + (<usize>index << alignof<U>()), __retain(changetype<usize>(result)));\n      } else {\n        store<U>(outStart + (<usize>index << alignof<U>()), result);\n      }\n      // releases result\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__allocArray(0, alignof<T>(), idof<Array<T>>())); // retains\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n      if (fn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = this.length_ - 1; index >= 0; --index) {\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\n    var base = this.dataStart;\n    var element = load<T>(base);\n    var lastIndex = length - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    store<T>(base + (<usize>lastIndex << alignof<T>()),\n      // @ts-ignore: cast\n      <T>null\n    );\n    this.length_ = lastIndex;\n    return element; // no need to retain -> is moved\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    var newLength = this.length_ + 1;\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    var dataStart = this.dataStart;\n    memory.copy(\n      dataStart + sizeof<T>(),\n      dataStart,\n      <usize>(newLength - 1) << alignof<T>()\n    );\n    if (isManaged<T>()) {\n      store<usize>(dataStart, __retain(changetype<usize>(value)));\n    } else {\n      store<T>(dataStart, value);\n    }\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length_;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var slice = changetype<Array<T>>(__allocArray(length, alignof<T>(), idof<Array<T>>())); // retains\n    var sliceBase = slice.dataStart;\n    var thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>length << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, __retain(ref));\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var length  = this.length_;\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\n    var result = changetype<Array<T>>(__allocArray(deleteCount, alignof<T>(), idof<Array<T>>())); // retains\n    var resultStart = result.dataStart;\n    var thisStart = this.dataStart;\n    var thisBase  = thisStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      for (let i = 0; i < deleteCount; ++i) {\n        store<usize>(resultStart + (<usize>i << alignof<T>()),\n          load<usize>(thisBase + (<usize>i << alignof<T>()))\n        );\n        // no need to retain -> is moved\n      }\n    } else {\n      memory.copy(\n        resultStart,\n        thisBase,\n        <usize>deleteCount << alignof<T>()\n      );\n    }\n    var offset = start + deleteCount;\n    if (length != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(length - offset) << alignof<T>()\n      );\n    }\n    this.length_ = length - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    var length = this.length_;\n    if (length) {\n      let front = this.dataStart;\n      let back = this.dataStart + (<usize>(length - 1) << alignof<T>());\n      while (front < back) {\n        let temp = load<T>(front);\n        store<T>(front, load<T>(back));\n        store<T>(back, temp);\n        front += sizeof<T>();\n        back -= sizeof<T>();\n      }\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    var length = this.length_;\n    if (length <= 1) return this;\n    var base = this.dataStart;\n    if (length == 2) {\n      let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\n      let b: T = load<T>(base); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        store<T>(base, b, sizeof<T>()); // arr[1] = b;\n        store<T>(base, a); // arr[0] = a;\n      }\n      return this;\n    }\n    SORT<T>(base, length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>()) return this.join_bool(separator);\n    if (isInteger<T>()) return this.join_int(separator);\n    if (isFloat<T>()) return this.join_flt(separator);\n    if (isString<T>()) return this.join_str(separator);\n    if (isArray<T>()) return this.join_arr(separator);\n    if (isReference<T>()) return this.join_ref(separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  private join_bool(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n    var dataStart = this.dataStart;\n    if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n    var sepLen = separator.length;\n    var valueLen = 5; // max possible length of element len(\"false\")\n    var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n    var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n    var offset = 0;\n    var value: bool;\n    for (let i = 0; i < lastIndex; ++i) {\n      value = load<bool>(dataStart + i);\n      valueLen = 4 + i32(!value);\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(select(\"true\", \"false\", value)),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n      if (sepLen) {\n        memory.copy(\n          changetype<usize>(result) + (<usize>offset << 1),\n          changetype<usize>(separator),\n          <usize>sepLen << 1\n        );\n        offset += sepLen;\n      }\n    }\n    value = load<bool>(dataStart + <usize>lastIndex);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      valueLen << 1\n    );\n    offset += valueLen;\n\n    if (estLen > offset) return result.substring(0, offset);\n    return result;\n  }\n\n  private join_int(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n    var dataStart = this.dataStart;\n    // @ts-ignore: type\n    if (!lastIndex) return changetype<string>(itoa<T>(load<T>(dataStart))); // retains\n\n    var sepLen = separator.length;\n    const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n    var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n    var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n    var offset = 0;\n    var value: T;\n    for (let i = 0; i < lastIndex; ++i) {\n      value = load<T>(dataStart + (<usize>i << alignof<T>()));\n      // @ts-ignore: type\n      offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n      if (sepLen) {\n        memory.copy(\n          changetype<usize>(result) + (<usize>offset << 1),\n          changetype<usize>(separator),\n          <usize>sepLen << 1\n        );\n        offset += sepLen;\n      }\n    }\n    value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n    if (estLen > offset) return result.substring(0, offset);\n    return result;\n  }\n\n  private join_flt(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n    var dataStart = this.dataStart;\n    if (!lastIndex) {\n      return changetype<string>(dtoa(\n        // @ts-ignore: type\n        load<T>(dataStart))\n      ); // retains\n    }\n\n    const valueLen = MAX_DOUBLE_LENGTH;\n    var sepLen = separator.length;\n    var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n    var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n    var offset = 0;\n    var value: T;\n    for (let i = 0; i < lastIndex; ++i) {\n      value = load<T>(dataStart + (<usize>i << alignof<T>()));\n      offset += dtoa_stream(changetype<usize>(result), offset,\n        // @ts-ignore: type\n        value\n      );\n      if (sepLen) {\n        memory.copy(\n          changetype<usize>(result) + (<usize>offset << 1),\n          changetype<usize>(separator),\n          <usize>sepLen << 1\n        );\n        offset += sepLen;\n      }\n    }\n    value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n    offset += dtoa_stream(changetype<usize>(result), offset,\n      // @ts-ignore: type\n      value\n    );\n    if (estLen > offset) return result.substring(0, offset);\n    return result;\n  }\n\n  private join_str(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n    var dataStart = this.dataStart;\n    if (!lastIndex) return load<string>(dataStart);\n\n    var sepLen = separator.length;\n    var estLen = 0;\n    var value: string | null;\n    for (let i = 0, len = lastIndex + 1; i < len; ++i) {\n      value = load<string>(dataStart + (<usize>i << alignof<T>()));\n      if (value !== null) estLen += value.length;\n    }\n    var offset = 0;\n    var result = changetype<string>(__alloc((estLen + sepLen * lastIndex) << 1, idof<string>())); // retains\n    for (let i = 0; i < lastIndex; ++i) {\n      value = load<string>(dataStart + (<usize>i << alignof<T>()));\n      if (value !== null) {\n        let valueLen = changetype<string>(value).length;\n        memory.copy(\n          changetype<usize>(result) + (<usize>offset << 1),\n          changetype<usize>(value),\n          <usize>valueLen << 1\n        );\n        offset += valueLen;\n      }\n      if (sepLen) {\n        memory.copy(\n          changetype<usize>(result) + (<usize>offset << 1),\n          changetype<usize>(separator),\n          <usize>sepLen << 1\n        );\n        offset += sepLen;\n      }\n    }\n    value = load<string>(dataStart + (<usize>lastIndex << alignof<T>()));\n    if (value !== null) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>changetype<string>(value).length << 1\n      );\n    }\n    return result;\n  }\n\n  private join_arr(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n\n    var result = \"\";\n    var sepLen = separator.length;\n    var base = this.dataStart;\n    var value: T;\n    if (!lastIndex) {\n      value = load<T>(base);\n      // @ts-ignore: type\n      return value ? value.join(separator) : \"\";\n    }\n    for (let i = 0; i < lastIndex; ++i) {\n      value = load<T>(base + (<usize>i << alignof<T>()));\n      // @ts-ignore: type\n      if (value) result += value.join(separator);\n      if (sepLen) result += separator;\n    }\n    value = load<T>(base + (<usize>lastIndex << alignof<T>()));\n    // @ts-ignore: type\n    if (value) result += value.join(separator);\n    return result; // registered by concatenation (FIXME: lots of garbage)\n  }\n\n  private join_ref(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n    var base = this.dataStart;\n    if (!lastIndex) return \"[object Object]\";\n\n    const valueLen = 15; // max possible length of element len(\"[object Object]\")\n    var sepLen = separator.length;\n    var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n    var result = changetype<string>(__alloc(estLen << 1, idof<string>()));\n    var offset = 0;\n    var value: T;\n    for (let i = 0; i < lastIndex; ++i) {\n      value = load<T>(base + (<usize>i << alignof<T>()));\n      if (value) {\n        memory.copy(\n          changetype<usize>(result) + (<usize>offset << 1),\n          changetype<usize>(\"[object Object]\"),\n          <usize>valueLen << 1\n        );\n        offset += valueLen;\n      }\n      if (sepLen) {\n        memory.copy(\n          changetype<usize>(result) + (<usize>offset << 1),\n          changetype<usize>(separator),\n          <usize>sepLen << 1\n        );\n        offset += sepLen;\n      }\n    }\n    if (load<T>(base + (<usize>lastIndex << alignof<T>()))) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(\"[object Object]\"),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (estLen > offset) return result.substring(0, offset);\n    return result;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit_impl(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    // automatically visits ArrayBufferView (.data) next\n  }\n}\n","// Common error messages for use accross the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { BLOCK, BLOCK_OVERHEAD } from \"./rt/common\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  var ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __instanceof(ref: usize, superId: u32): bool { // keyword\n  var id = changetype<BLOCK>(ref - BLOCK_OVERHEAD).rtId;\n  var ptr = __rtti_base;\n  if (id <= load<u32>(ptr)) {\n    do if (id == superId) return true;\n    while (id = changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __allocArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  var array = __alloc(offsetof<i32[]>(), id);\n  var bufferSize = <usize>length << alignLog2;\n  var buffer = __alloc(bufferSize, idof<ArrayBuffer>());\n  store<usize>(array, __retain(buffer), offsetof<ArrayBufferView>(\"data\"));\n  changetype<ArrayBufferView>(array).dataStart = buffer;\n  changetype<ArrayBufferView>(array).dataLength = bufferSize;\n  store<i32>(changetype<usize>(array), length, offsetof<i32[]>(\"length_\"));\n  if (data) memory.copy(buffer, data, bufferSize);\n  return array;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// @builtin @unsafe\n// export declare function __alloc(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ref: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ref: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __retain(ref: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __release(ref: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ref: usize, cookie: u32): void;\n","import { AL_MASK, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"rt/common\";\n\n// @ts-ignore: decorator\n@lazy\nvar startOffset: usize = (__heap_base + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@lazy\nvar offset: usize = startOffset;\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __alloc(size: usize, id: u32): usize {\n  if (size > BLOCK_MAXSIZE) unreachable();\n  var ptr = offset + BLOCK_OVERHEAD;\n  var newPtr = (ptr + max<usize>(size, 1) + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  if (newPtr > <usize>pagesBefore << 16) {\n    let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) unreachable(); // out of memory\n    }\n  }\n  offset = newPtr;\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  block.rtId = id;\n  block.rtSize = size;\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __realloc(ref: usize, size: usize): usize {\n  var block = changetype<BLOCK>(ref - BLOCK_OVERHEAD);\n  var oldSize = <usize>block.rtSize;\n  if (size > oldSize) {\n    let newRef = __alloc(size, block.rtId);\n    memory.copy(newRef, ref, oldSize);\n    ref = newRef;\n  } else {\n    block.rtSize = size;\n  }\n  return ref;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __free(ref: usize): void {\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nfunction __reset(): void { // special\n  offset = startOffset;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __retain(ref: usize): usize {\n  return ref;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __release(ref: usize): void {\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ref: usize, cookie: u32): void {\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n}\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    let w: u32, x: u32;\n\n    // copy 1 byte each until src is aligned to 4 bytes\n    while (n && (src & 3)) {\n      store<u8>(dest++, load<u8>(src++));\n      n--;\n    }\n\n    // if dst is aligned to 4 bytes as well, copy 4 bytes each\n    if ((dest & 3) == 0) {\n      while (n >= 16) {\n        store<u32>(dest     , load<u32>(src     ));\n        store<u32>(dest +  4, load<u32>(src +  4));\n        store<u32>(dest +  8, load<u32>(src +  8));\n        store<u32>(dest + 12, load<u32>(src + 12));\n        src += 16; dest += 16; n -= 16;\n      }\n      if (n & 8) {\n        store<u32>(dest    , load<u32>(src    ));\n        store<u32>(dest + 4, load<u32>(src + 4));\n        dest += 8; src += 8;\n      }\n      if (n & 4) {\n        store<u32>(dest, load<u32>(src));\n        dest += 4; src += 4;\n      }\n      if (n & 2) { // drop to 2 bytes each\n        store<u16>(dest, load<u16>(src));\n        dest += 2; src += 2;\n      }\n      if (n & 1) { // drop to 1 byte\n        store<u8>(dest++, load<u8>(src++));\n      }\n      return;\n    }\n\n    // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n    // doing shifts if faster when copying enough bytes (here: 32 or more)\n    if (n >= 32) {\n      switch (dest & 3) {\n        // known to be != 0\n        case 1: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          n -= 3;\n          while (n >= 17) {\n            x = load<u32>(src + 1);\n            store<u32>(dest, w >> 24 | x << 8);\n            w = load<u32>(src + 5);\n            store<u32>(dest + 4, x >> 24 | w << 8);\n            x = load<u32>(src + 9);\n            store<u32>(dest + 8, w >> 24 | x << 8);\n            w = load<u32>(src + 13);\n            store<u32>(dest + 12, x >> 24 | w << 8);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n        case 2: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          n -= 2;\n          while (n >= 18) {\n            x = load<u32>(src + 2);\n            store<u32>(dest, w >> 16 | x << 16);\n            w = load<u32>(src + 6);\n            store<u32>(dest + 4, x >> 16 | w << 16);\n            x = load<u32>(src + 10);\n            store<u32>(dest + 8, w >> 16 | x << 16);\n            w = load<u32>(src + 14);\n            store<u32>(dest + 12, x >> 16 | w << 16);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n        case 3: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          n -= 1;\n          while (n >= 19) {\n            x = load<u32>(src + 3);\n            store<u32>(dest, w >> 8 | x << 24);\n            w = load<u32>(src + 7);\n            store<u32>(dest + 4, x >> 8 | w << 24);\n            x = load<u32>(src + 11);\n            store<u32>(dest + 8, w >> 8 | x << 24);\n            w = load<u32>(src + 15);\n            store<u32>(dest + 12, x >> 8 | w << 24);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n      }\n    }\n\n    // copy remaining bytes one by one\n    if (n & 16) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 8) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 4) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 2) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 1) {\n      store<u8>(dest++, load<u8>(src++));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src + n <= dest || dest + n <= src) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    store<u8>(dest, c);\n    store<u8>(dest + n - 1, c);\n    if (n <= 2) return;\n\n    store<u8>(dest + 1, c);\n    store<u8>(dest + 2, c);\n    store<u8>(dest + n - 2, c);\n    store<u8>(dest + n - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest + 3, c);\n    store<u8>(dest + n - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    store<u32>(dest, c32);\n    store<u32>(dest + n - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest + 4, c32);\n    store<u32>(dest + 8, c32);\n    store<u32>(dest + n - 12, c32);\n    store<u32>(dest + n - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest + 12, c32);\n    store<u32>(dest + 16, c32);\n    store<u32>(dest + 20, c32);\n    store<u32>(dest + 24, c32);\n    store<u32>(dest + n - 28, c32);\n    store<u32>(dest + n - 24, c32);\n    store<u32>(dest + n - 20, c32);\n    store<u32>(dest + n - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest + 8, c64);\n      store<u64>(dest + 16, c64);\n      store<u64>(dest + 24, c64);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n  if (vl == vr) return 0;\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\n    n--; vl++; vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n","import { COMPARATOR, SORT as SORT_IMPL } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return FILL<Int8Array, i8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    return SORT<Int8Array, i8>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i8>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return FILL<Uint8Array, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    return SORT<Uint8Array, u8>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return FILL<Uint8ClampedArray, u8>(this, value, start, end);\n  }\n\n  sort(fn: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    return SORT<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  subarray(start: i32 = 0, end: i32 = 0x7fffffff): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return FILL<Int16Array, i16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    return SORT<Int16Array, i16>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i16>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return FILL<Uint16Array, u16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    return SORT<Uint16Array, u16>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u16>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return FILL<Int32Array, i32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    return SORT<Int32Array, i32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i32>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return FILL<Uint32Array, u32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    return SORT<Uint32Array, u32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u32>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return FILL<Int64Array, i64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    return SORT<Int64Array, i64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i64>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return FILL<Uint64Array, u64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    return SORT<Uint64Array, u64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u64>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return FILL<Float32Array, f32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    return SORT<Float32Array, f32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f32>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\") // unchecked is built-in\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\") // unchecked is built-in\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return FILL<Float64Array, f64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    return SORT<Float64Array, f64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f64>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILL<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var dataStart = array.dataStart;\n  var length = array.length;\n  start = start < 0 ? max(length + start, 0) : min(start, length);\n  end   = end   < 0 ? max(length + end,   0) : min(end,   length);\n  if (sizeof<T>() == 1) {\n    if (start < end) memory.fill(dataStart + <usize>start, <u8>value, <usize>(end - start));\n  } else {\n    for (; start < end; ++start) {\n      store<T>(dataStart + (<usize>start << alignof<T>()), value);\n    }\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SORT<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  comparator: (a: T, b: T) => i32\n): TArray {\n  var length = array.length;\n  if (length <= 1) return array;\n  var base = array.dataStart;\n  if (length == 2) {\n    let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\n    let b: T = load<T>(base); // b = arr[0]\n    if (comparator(a, b) < 0) {\n      store<T>(base, b, sizeof<T>()); // arr[1] = b\n      store<T>(base, a); // arr[0] = a\n    }\n    return array;\n  }\n  SORT_IMPL<T>(base, length, comparator);\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var len = <i32>array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n  var out = changetype<TArray>(__alloc(offsetof<TArray>(), idof<TArray>())); // retains\n  out.data = array.data; // retains\n  out.dataStart = array.dataStart + (<usize>begin << alignof<T>());\n  out.dataLength = (end - begin) << alignof<T>();\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var dataStart = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var length = array.length;\n  var dataStart = array.dataStart;\n  var out = instantiate<TArray>(length);\n  var outDataStart = out.dataStart;\n  for (let i = 0; i < length; i++) {\n    store<T>(\n      outDataStart + (<usize>i << alignof<T>()),\n      fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var length: isize = array.length;\n  if (length == 0 || index >= length) return -1;\n  if (index < 0) index = max(length + index, 0);\n  var dataStart = array.dataStart;\n  while (index < length) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var length: isize = array.length;\n  if (length == 0) return -1;\n  if (index < 0) index = length + index; // no need to clamp\n  else if (index >= length) index = length - 1;\n  var dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REVERSE<TArray extends ArrayBufferView, T>(array: TArray): TArray {\n  var dataStart = array.dataStart;\n  for (let front: usize = 0, back: usize = array.length - 1; front < back; ++front, --back) {\n    let frontPtr = dataStart + (front << alignof<T>());\n    let backPtr = dataStart + (back << alignof<T>());\n    let temp = load<T>(frontPtr);\n    store<T>(frontPtr, load<T>(backPtr));\n    store<T>(backPtr, temp);\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): TArray {\n  var bufferByteLength = buffer.byteLength;\n  if (<u32>byteOffset >= <u32>bufferByteLength) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  var byteLength: i32;\n  if (length < 0) {\n    if (length == -1) {\n      const mask = <i32>(1 << alignof<T>() - 1);\n      if (buffer.byteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      } else {\n        byteLength = buffer.byteLength;\n      }\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = length << alignof<T>();\n  }\n  if (byteOffset + byteLength > buffer.byteLength) {\n    throw new RangeError(E_INVALIDLENGTH);\n  }\n  var out = changetype<TArray>(__alloc(offsetof<TArray>(), idof<TArray>()));\n  out.data = buffer;\n  out.dataLength = byteLength;\n  out.dataStart = changetype<usize>(buffer) + <usize>byteOffset;\n  return out;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_MAXSIZE, BLOCK_OVERHEAD } from \"./rt/common\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  @unsafe data: ArrayBuffer;\n  @unsafe dataStart: usize;\n  @unsafe dataLength: u32;\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(length = length << alignLog2, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    this.data = changetype<ArrayBuffer>(buffer); // retains\n    this.dataStart = buffer;\n    this.dataLength = length;\n  }\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.data));\n  }\n\n  get byteLength(): i32 {\n    return this.dataLength;\n  }\n\n  get length(): i32 {\n    ERROR(\"missing implementation: subclasses must implement ArrayBufferView#length\");\n    return unreachable();\n  }\n}\n\n@sealed export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (value) {\n      if (value instanceof Int8Array) return true;\n      if (value instanceof Uint8Array) return true;\n      if (value instanceof Uint8ClampedArray) return true;\n      if (value instanceof Int16Array) return true;\n      if (value instanceof Uint16Array) return true;\n      if (value instanceof Int32Array) return true;\n      if (value instanceof Uint32Array) return true;\n      if (value instanceof Int64Array) return true;\n      if (value instanceof Uint64Array) return true;\n      if (value instanceof Float32Array) return true;\n      if (value instanceof Float64Array) return true;\n      if (value instanceof DataView) return true;\n    }\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(<usize>length, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    return changetype<ArrayBuffer>(buffer); // retains\n  }\n\n  get byteLength(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = __alloc(outSize, idof<ArrayBuffer>());\n    memory.copy(out, changetype<usize>(this) + <usize>begin, outSize);\n    return changetype<ArrayBuffer>(out); // retains\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","import { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { ArrayBuffer } from \"./arraybuffer\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from \"./util/error\";\n\n// TODO: there is probably a smarter way to check byteOffset for accesses larger than 1 byte\n\nexport class DataView {\n\n  private data: ArrayBuffer;\n  private dataStart: usize;\n  private dataLength: i32;\n\n  constructor(\n    buffer: ArrayBuffer,\n    byteOffset: i32 = 0,\n    byteLength: i32 = buffer.byteLength\n  ) {\n    if (\n      i32(<u32>byteLength > <u32>BLOCK_MAXSIZE) |\n      i32(<u32>byteOffset + byteLength > <u32>buffer.byteLength)\n    ) throw new RangeError(E_INVALIDLENGTH);\n    this.data = buffer; // retains\n    var dataStart = changetype<usize>(buffer) + <usize>byteOffset;\n    this.dataStart = dataStart;\n    this.dataLength = byteLength;\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.data));\n  }\n\n  get byteLength(): i32 {\n    return this.dataLength;\n  }\n\n  getFloat32(byteOffset: i32, littleEndian: boolean = false): f32 {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 4 > this.dataLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    return littleEndian\n      ? load<f32>(this.dataStart + <usize>byteOffset)\n      : reinterpret<f32>(\n          bswap<u32>(\n            load<u32>(this.dataStart + <usize>byteOffset)\n          )\n        );\n  }\n\n  getFloat64(byteOffset: i32, littleEndian: boolean = false): f64 {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 8 > this.dataLength)\n     ) throw new RangeError(E_INDEXOUTOFRANGE);\n    return littleEndian\n      ? load<f64>(this.dataStart + <usize>byteOffset)\n      : reinterpret<f64>(\n          bswap<u64>(\n            load<u64>(this.dataStart + <usize>byteOffset)\n          )\n        );\n  }\n\n  getInt8(byteOffset: i32): i8 {\n    if (<u32>byteOffset >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>byteOffset);\n  }\n\n  getInt16(byteOffset: i32, littleEndian: boolean = false): i16 {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 2 > this.dataLength)\n     ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: i16 = load<i16>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<i16>(result);\n  }\n\n  getInt32(byteOffset: i32, littleEndian: boolean = false): i32 {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 4 > this.dataLength)\n     ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: i32 = load<i32>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<i32>(result);\n  }\n\n  getUint8(byteOffset: i32): u8 {\n    if (<u32>byteOffset >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>byteOffset);\n  }\n\n  getUint16(byteOffset: i32, littleEndian: boolean = false): u16 {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 2 > this.dataLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: u16 = load<u16>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u16>(result);\n  }\n\n  getUint32(byteOffset: i32, littleEndian: boolean = false): u32 {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 4 > this.dataLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: u32 = load<u32>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u32>(result);\n  }\n\n  setFloat32(byteOffset: i32, value: f32, littleEndian: boolean = false): void {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 4 > this.dataLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    if (littleEndian) store<f32>(this.dataStart + <usize>byteOffset, value);\n    else store<u32>(this.dataStart + <usize>byteOffset, bswap<u32>(reinterpret<u32>(value)));\n  }\n\n  setFloat64(byteOffset: i32, value: f64, littleEndian: boolean = false): void {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 8 > this.dataLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    if (littleEndian) store<f64>(this.dataStart + <usize>byteOffset, value);\n    else store<u64>(this.dataStart + <usize>byteOffset, bswap<u64>(reinterpret<u64>(value)));\n  }\n\n  setInt8(byteOffset: i32, value: i8): void {\n    if (<u32>byteOffset >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>byteOffset, value);\n  }\n\n  setInt16(byteOffset: i32, value: i16, littleEndian: boolean = false): void {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 2 > this.dataLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<i16>(value));\n  }\n\n  setInt32(byteOffset: i32, value: i32, littleEndian: boolean = false): void {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 4 > this.dataLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<i32>(value));\n  }\n\n  setUint8(byteOffset: i32, value: u8): void {\n    if (<u32>byteOffset >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>byteOffset, value);\n  }\n\n  setUint16(byteOffset: i32, value: u16, littleEndian: boolean = false): void {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 2 > this.dataLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));\n  }\n\n  setUint32(byteOffset: i32, value: u32, littleEndian: boolean = false): void {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 4 > this.dataLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));\n  }\n\n  // Non-standard additions that make sense in WebAssembly, but won't work in JS:\n\n  getInt64(byteOffset: i32, littleEndian: boolean = false): i64 {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 8 > this.dataLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result: i64 = load<i64>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<i64>(result);\n  }\n\n  getUint64(byteOffset: i32, littleEndian: boolean = false): u64 {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 8 > this.dataLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    var result = load<u64>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u64>(result);\n  }\n\n  setInt64(byteOffset: i32, value: i64, littleEndian: boolean = false): void {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 8 > this.dataLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<i64>(value));\n  }\n\n  setUint64(byteOffset: i32, value: u64, littleEndian: boolean = false): void {\n    if (\n      i32(byteOffset < 0) |\n      i32(byteOffset + 8 > this.dataLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));\n  }\n\n  toString(): string {\n    return \"[object DataView]\";\n  }\n}\n","export function bswap<T extends number>(value: T): T {\n  if (isInteger<T>()) {\n    if (sizeof<T>() == 2) {\n      return <T>((value << 8) | ((value >> 8) & <T>0x00FF));\n    }\n    if (sizeof<T>() == 4) {\n      return <T>(\n        rotl<u32>(<u32>value & 0xFF00FF00, 8) |\n        rotr<u32>(<u32>value & 0x00FF00FF, 8)\n      );\n    }\n    if (sizeof<T>() == 8) {\n      let a = (<u64>value >> 8) & 0x00FF00FF00FF00FF;\n      let b = (<u64>value & 0x00FF00FF00FF00FF) << 8;\n      let v = a | b;\n\n      a = (v >> 16) & 0x0000FFFF0000FFFF;\n      b = (v & 0x0000FFFF0000FFFF) << 16;\n\n      return <T>rotr<u64>(a | b, 32);\n    }\n    return value;\n  }\n  assert(false);\n  return value;\n}\n\nexport function bswap16<T extends number>(value: T): T {\n  if (isInteger<T>() && sizeof<T>() <= 4) {\n    if (sizeof<T>() == 2) {\n      return <T>((value << 8) | ((value >> 8) & <T>0x00FF));\n    } else if (sizeof<T>() == 4) {\n      return <T>(((value << 8) & <T>0xFF00) | ((value >> 8) & <T>0x00FF) | (value & <T>0xFFFF0000));\n    }\n    return value;\n  }\n  assert(false);\n  return value;\n}\n","// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: void): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: void): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function load<T>(offset: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function store<T>(offset: usize, value: void, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: void): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function call_indirect<T>(target: void, ...args: void[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function call_direct<T>(target: void, ...args: void[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: void[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load<T>(offset: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function store<T>(offset: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: void): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: void): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: void): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function store8(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function store16(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function store(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(offset: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(offset: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(offset: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function store8(offset: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function store16(offset: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function store(offset: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xchg(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function cmpxchg(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: void): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(offset: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function store8(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function store16(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function store32(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function store(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(offset: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(offset: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(offset: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(offset: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function store8(offset: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function store16(offset: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function store32(offset: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function store(offset: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xchg(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function cmpxchg(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: void): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: void): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: void): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: void): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: void): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: void): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: void): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: void): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function store(offset: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: void): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function store(offset: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function store(offset: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128; // except i64\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_s_f32x4_sat(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_u_f32x4_sat(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_s_f64x2_sat(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_u_f64x2_sat(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_s_i32x4(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_u_i32x4(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_s_i64x2(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_u_i64x2(a: v128): v128;\n}\n\nexport namespace v8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n}\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n"]}
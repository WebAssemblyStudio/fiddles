<html>
<head>
<style>
html, body { height: 100%; margin: 0; overflow: hidden; }
canvas { width: 100%; height: 100%; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>

// Set up the canvas with a 2D rendering context
var cnv = document.getElementById("canvas");
var ctx = cnv.getContext("2d");
var bcr = cnv.getBoundingClientRect();
cnv.width = bcr.width | 0;
cnv.height = bcr.height | 0;

// Compute the size of the universe (here: 2px per cell)
var w = bcr.width >>> 1;
var h = bcr.height >>> 1;
var s = w * h; // memory required to store either input or output
var S = s + s; // total memory required to store input and output

// Compute the size of and instantiate the module's memory
var nPages = ((S + 0xffff) & ~0xffff) >>> 16; // aligned up in 64k units
var memory = new WebAssembly.Memory({ initial: nPages });

// Fetch and instantiate the module
WebAssembly.instantiateStreaming(fetch("../out/main.wasm"), {
  env: { memory: memory }
})
.then(module => {
  var exports = module.instance.exports;

  // Tell the module about the universe's width and height
  exports.init(w, h);

  // Fill input at [0, s-1] with random live cells
  var mem = new Uint8Array(memory.buffer);
  for (var y = 0; y < h; ++y)
    for (var x = 0; x < w; ++x)
      mem[y * w + x] = Math.random() > 0.1 ? 0 : 1;

  // Update about 30 times a second
  (function update() {
    setTimeout(update, 30);
    exports.step();
    mem.copyWithin(0, s, S); // copy output at [s, S] to input at [0, s]
  })();

  // Keep rendering the output at [s, S]
  (function render() {
    requestAnimationFrame(render);
    ctx.fillStyle = "rgba(238,238,238,0.67)";
    ctx.fillRect(0, 0, w << 1, h << 1);
    ctx.fillStyle = "#333";
    for (var y = 0; y < h; ++y)
      for (var x = 0; x < w; ++x)
        if (mem[s + y * w + x])
          ctx.fillRect(x << 1, y << 1, 2, 2);
  })();

}).catch(err => {
  throw err;
});
</script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body { background: #111; }
    canvas { width: 100%; height: 100%; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
  WebAssembly.instantiateStreaming(fetch("../out/main.wasm"), {
  env: {
    abort: function(msg, file, line, column) {
      console.error("abort called at main.ts:" + line + ":" + column);
    }
  }
}).then(result => {
  const instance = result.instance;

  // Set up the canvas with a 2D rendering context
  var cnv = document.getElementById("canvas");
  var size = cnv.getBoundingClientRect();
  var ctx = cnv.getContext("2d");
  var w = cnv.width = size.width,
      h = cnv.height = size.height,
      s = w * h, // memory required to store either input or output
      S = s + s; // total memory required to store input and output

  // Grow the (exported) memory if its size isn't sufficient
  var memory = instance.exports.memory;
  if (memory.buffer.byteLength < S)
    memory.grow(Math.ceil((S - memory.buffer.byteLength) / 65536));

  // Initialize with width and height
  instance.exports.init(w, h);

  // Fill input at [0, s-1] with random live cells
  var mem = new Uint8Array(memory.buffer);
  for (var y = 0; y < h; ++y)
    for (var x = 0; x < w; ++x)
      mem[y * w + x] = Math.random() > 0.1 ? 0 : 1;

  // Update about 30 times a second
  (function update() {
    setTimeout(update, 33);
    instance.exports.step();
    mem.set(mem.subarray(s, S), 0); // copy output -> input
  })();

  // Keep rendering the output at [s, 2*s-1]
  (function render() {
    requestAnimationFrame(render);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = "#999";
    for (var y = 0; y < h; ++y)
      for (var x = 0; x < w; ++x)
        if (mem[s + y * w + x])
          ctx.fillRect(x, y, 1, 1);
  })();
});
</script>
</body>
</html>
